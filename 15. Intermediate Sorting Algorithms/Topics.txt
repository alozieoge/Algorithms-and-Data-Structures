
Objectives:
- Understand the limitations of previous sorting algorithms. 
- Implement merge sort
- Implement quick sort. 
- Implement radix sort.

Previous sorting algorithms do not scale well to very large datasets.

Faster sorting algorithms
- Can improve time complexity from O(n^2) to O(n.logn).
- Trade-off between efficiency and simplicity. 
- More efficient sorting algorithms are much less simple and take longer to understand.


1. Merge Sort
- Merge sort is a combination of 3 things:
  - Splitting
  - Merging
  - Sorting

- Explots the fact that arrays of 0 or 1 element are always sorted.
- Works by decomposing an array into smaller arrays of 0 or 1 element, then building up a newly sorted array. 
  - Divide and Conquer
  - Premise: It is easier to merge 2 sorted arrays than merging 2 unsorted arrays.

Merge Sort Implementation
- First implement a function for merging 2 sorted arrays. 
- Given 2 sorted arrays, this helper function should create a new array which is also sorted and consists of all the elements in the 2 input arrays. 
- This function should: 
  - take O(n + m) time -> only iterate once over each item in each array.
  - use O(n + m) space -> create a new array whose size is n + m.
  - not modify the parameters passed to it.
  
Merge Sort Big O
- Time Complexity: O(n.log n)
- Space Complexity: O(n)

- Merge sort will always split and merge all the elements in the input array, irrespective of the scenario. 
- There are O(log n) decompositions. 
  -The number of times that the input array will be split to reach all arrays with 0 or 1 element is log n.
- There are O(n) comparisons per decompisition.


2. 
