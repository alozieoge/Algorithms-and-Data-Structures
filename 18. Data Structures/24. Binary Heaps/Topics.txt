Objectives:
- What is a binary heap?
- Compare and contrast min and max binary heaps.
- Implement basic methods on heaps.
- Understand use cases for binary heaps and other data structures that can be constructed from them.


1. What is a binary heap?
- A binar heap is a tree data structure similar to a binary search tree, but with different ordering rules. 

- Max Binary Heap: Parent nodes are always larger than child nodes.
- Min Binary Heap: Parent nodes are always smaller than child nodes.

Rules for Max Binary Heap
a. Each parent has at most 2 child nodes. 
b. The value of each parent node is always greater than its child nodes (vice-versa for min binary heaps).
c. There is no guaranteed order between sibling nodes (nodes on the same level).
d. A binary heap is as compact as possible. 
   All the children of each node are as full as can be. 
   Left child nodes are always filled first before right child nodes.
   
Why we need binary heaps?
- Used to implement Priority Queues, a commonly used data structure.
- Used with Graph traversal algorithms.


2. Representing a Binary Heap
- A binary heap can easily be represented by a built-in list or array.

- For any index of an array n: 
  - the left child is stored at index: 2n + 1, 
  - the right child is stored at index: 2n + 2

- Conversely, for any child node at index n:
  - its parent is stored at index: floor((n - 1)/2)


3. Max Binary Heap Class and Methods
- The MaxBinaryHeap class has only 1 property:
  - values = []  // initialized as an empty array.


a. insert(value)
- Inserts a value into the max binary heap.

Steps:
- Add value to the end of the array.
- 'Bubble up' the value to the correct position by comparing and swapping with the parent node at each step.


b. extractMax() / removeRoot()
- Removes the maximum value (root) from and readjusts the max binary heap.

Steps:
- Remove the root value. 
- Replace it with the most recently added value. 
- Adjust the heap so the root moves to its correct position (sink down).
  - Sink down procedure: 
    + Compare the node with its 2 child nodes.
    + Swap it with the largest of the 2 child nodes, else stop. 
    + Repeat. 
